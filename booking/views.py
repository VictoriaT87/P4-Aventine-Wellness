import datetime

from django.shortcuts import render
from django.contrib.auth.mixins import LoginRequiredMixin, UserPassesTestMixin
from django.http import HttpResponseRedirect
from django.contrib.auth.models import User
from django.urls import reverse, reverse_lazy
from .models import Appointment
from .forms import AppointmentForm
from django.contrib import messages

from bootstrap_datepicker_plus.widgets import DatePickerInput

from django.views.generic import (
    CreateView,
    DeleteView,
    UpdateView,
)


# Create your views here.


def daylist():
    """
    Generate a list of days for the next 7 days.
    Check if an appointment slot is booked.
    """
    # https://www.geeksforgeeks.org/creating-a-list-of-range-of-dates-in-python/
    res = []
    now = datetime.date.today()
    for days in range(7):
        day = {}
        today = now + datetime.timedelta(days=days)
        weekday = today.strftime("%A").upper()
        day["date"] = today.strftime("%d-%m-%Y")
        day["day"] = weekday
        day["slot1_booked"] = (
            Appointment.objects.filter(date=str(today))
            .filter(timeblock="9 AM")
            .exists()
        )
        day["slot2_booked"] = (
            Appointment.objects.filter(date=str(today))
            .filter(timeblock="11 AM")
            .exists()
        )
        day["slot3_booked"] = (
            Appointment.objects.filter(date=str(today))
            .filter(timeblock="1 PM")
            .exists()
        )
        day["slot4_booked"] = (
            Appointment.objects.filter(date=str(today))
            .filter(timeblock="3 PM")
            .exists()
        )
        res.append(day)
    return res


def appointment(request):
    """
    Show available appointments, generated by the daylist function
    """
    context = {"days": daylist()}
    if request.user.is_authenticated:
        # Render the appointment page
        return render(request, "appointments/appointment.html", context)
    else:
        # Redirect to a login page
        return HttpResponseRedirect("../accounts/login/")


class AppointmentCreateView(LoginRequiredMixin, CreateView):
    """
    Create an Appointment
    """

    form_class = AppointmentForm
    template_name = "appointments/appointment_confirm_form.html"

    def get_initial(self):
        return {
            "user": self.kwargs.get("user"),
            "date": self.kwargs.get("date"),
            "timeblock": self.kwargs.get("timeblock"),
        }

    def get_form(self, form_class=AppointmentForm):
        form = super(AppointmentCreateView, self).get_form(form_class)
        form.fields["date"].disabled = True
        form.fields["timeblock"].disabled = True
        return form

    def get_form_kwargs(self, *args, **kwargs):
        kwargs = super(AppointmentCreateView,
                       self).get_form_kwargs(*args, **kwargs)
        kwargs["user"] = self.request.user
        return kwargs

    def get_success_url(self):
        return reverse("user-profile")

    def form_valid(self, form):
        form.instance.user = self.request.user
        if form.is_valid():
            messages.success(
                self.request, "Your appointment was successfully booked!")
            super().form_valid(form)
            return HttpResponseRedirect(self.get_success_url())
        else:
            messages.error(self.request, "Failed to save appointment")


class AppointmentEditView(LoginRequiredMixin, UserPassesTestMixin, UpdateView):
    """
    Update an Appointment
    """

    template_name = "appointments/edit_appointment.html"
    form_class = AppointmentForm
    queryset = Appointment.objects.all()

    def get_form(self, form_class=AppointmentForm):
        form = super(AppointmentEditView, self).get_form(form_class)
        form.user = self.request.user
        form.fields["date"].widget = DatePickerInput(
            options={
                "format": "DD/MM/YYYY",
                "minDate": (
                    datetime.datetime.today() + datetime.timedelta(days=1)
                ).strftime("%Y-%m-%d 00:00:00"),
                "maxDate": (
                    datetime.datetime.today() + datetime.timedelta(days=7)
                ).strftime("%Y-%m-%d 23:59:59"),
                "showTodayButton": True,
            }
        )
        return form

    def test_func(self):
        appt = self.get_object()
        return self.request.user == appt.user

    def get_success_url(self):
        return reverse("user-profile")

    def form_valid(self, form):
        # Validate form to see if user already has a booking that day
        appointment = self.get_object()

        date = form.cleaned_data.get("date")
        timeblock = form.cleaned_data.get("timeblock")

        existing_appointment = (
            Appointment.objects.filter(
                user=self.request.user, date=date, timeblock=timeblock
            )
            .exclude(pk=appointment.pk)
            .first()
        )

        if existing_appointment:
            messages.error(
                self.request,
                "Failed to save appointment. Appointment already exists for the chosen date and time.",
            )
            return self.form_invalid(form)
        else:
            form.instance.user = self.request.user
            messages.success(
                self.request, "Your appointment was successfully changed!")
            response = super().form_valid(form)
            return response


class AppointmentDeleteView(LoginRequiredMixin, UserPassesTestMixin, DeleteView):
    """
    Delete an Appointment
    """

    model = Appointment
    template_name = "appointments/delete_appointment.html"
    success_url = reverse_lazy("user-profile")
    success_message = "Appointment deleted successfully."

    def test_func(self):
        obj = self.get_object()
        return obj.user == self.request.user

    def delete(self, request, *args, **kwargs):
        messages.success(self.request, self.success_message)
        return super(AppointmentDeleteView, self).delete(request, *args, **kwargs)
